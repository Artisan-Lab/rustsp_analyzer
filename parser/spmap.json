{"map":{"https://doc.rust-lang.org/core/primitive.i8.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > i128::MAX` or `self * rhs < i128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `usize::MIN`."]}],"https://doc.rust-lang.org/core/alloc/trait.Allocator.html#tymethod.deallocate":[{"sp":"Layout","f":"layout","des":["`layout` must fit that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.increment_strong_count":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Rc::into_raw`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.exact_div.html":[{"sp":"Bounded","f":"x","des":["Resulting in undefined behavior where `x % y != 0`.","Resulting in undefined behavior where `x == T::MIN && y == -1`."]},{"sp":"Bounded","f":"y","des":["Resulting in undefined behavior where `y == 0`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroIsize.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.byte_offset_from":[{"sp":"Allocated","f":"origin","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.from_raw_in":[{"sp":"DualOwned","f":"retval","des":["After calling this function, the raw pointer is owned by the resulting `Box`. A double-free may occur if the function is called twice on the same raw pointer."]},{"sp":"Allocated","f":"self","des":["For non-zero-sized values, a `Box` will use the in the given allocator for its allocation.","For zero-sized values, the `Box` pointer still has to be valid for reads and writes (always be non-null pointers)."]},{"sp":"Initialized","f":"self","des":["Recreate a `Box` which was previously converted to a raw pointer using `Box::into_raw_with_allocator.","It is valid to convert both ways between a `Box` and a raw pointer allocated with the given allocator, given that the `Layout` used with the allocator is correct for the type."]},{"sp":"Layout","f":"self","des":["The `Box` pointer has to be sufficiently aligned (always be fully aligned)."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_from_nonoverlapping":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size."]},{"sp":"DualOwned","f":"src","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]},{"sp":"Untyped","f":"src","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.assume_init-1":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.decrement_strong_count_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method."]},{"sp":"Freed","f":"ptr","des":["This method can be used to release the final `Rc` and backing storage, but should not be called after the final `Rc` has been released."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Rc::into_raw`."]}],"https://doc.rust-lang.org/core/alloc/trait.Allocator.html#method.shrink":[{"sp":"Bounded","f":"new_layout","des":["`new_layout.size()` must be smaller than or equal to `old_layout.size()`."]},{"sp":"Layout","f":"old_layout","des":["`old_layout` must fit that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]},{"sp":"Freed","f":"ptr","des":["If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. "]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_ref_unchecked-1":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/ptr/fn.write_unaligned.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Leaked","f":"dst","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.assume_init":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.BorrowedHandle.html#method.borrow_raw":[{"sp":"SystemIO","f":"handle","des":["The resource pointed to by handle must be a valid open handle, it must remain open for the duration of the returned `BorrowedHandle`."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > u128::MAX` or `self - rhs < u128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.tuple.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.vtable_size.html":[{"sp":"EST","f":"ptr","des":["`ptr` must point to a vtable."]}],"https://doc.rust-lang.org/core/intrinsics/fn.volatile_set_memory.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned ('min_align_of::<T>()')."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI32.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > i32::MAX`, or `self * rhs < i32::MIN`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.downcast_unchecked":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.ptr_offset_from.html":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`base` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`ptr` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"EST","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read-1":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/intrinsics/fn.fadd_fast.html":[{"sp":"Bounded","f":"x","des":["Float addition that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read_volatile":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`.","However, storing non-`Copy` types in volatile memory is almost certainly incorrect."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.replace":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"src","des":["Neither value is dropped."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.write_bytes":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Untyped","f":"self","des":["Additionally, note that changing `self` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.as_chunks_unchecked_mut":[{"sp":"Bounded","f":"self","des":["The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).","`N != 0`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFull.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/fn.write.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/intrinsics/fn.vtable_align.html":[{"sp":"EST","f":"ptr","des":["`ptr` must point to a vtable."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.offset_from":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.byte_add":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > u8::MAX` or `self - rhs < u8::MIN`."]}],"https://doc.rust-lang.org/core/pin/struct.Pin.html#method.new_unchecked":[{"sp":"Pinned","f":"retval","des":["If the constructed `Pin<P>` does not guarantee that the data `P` points to is pinned, that is a violation of the API contract and may lead to undefined behavior in later (safe) operations.","`P::Deref` and `P::DerefMut` implementations must not move out of their self arguments: `Pin::as_mut` and `Pin::as_ref` will call `DerefMut::deref_mut` and `Deref::deref` on the pinned pointer and expect these methods to uphold the pinning invariants.","The reference `P` dereferences to will not be moved out of again; in particular, it must not be possible to obtain a `&mut P::Target` and then move out of that reference."]}],"https://doc.rust-lang.org/core/ptr/fn.write_bytes.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.BorrowedSocket.html#method.borrow_raw":[{"sp":"Bounded","f":"socket","des":["The resource pointed to by raw must not have the value `INVALID_SOCKET`."]},{"sp":"SystemIO","f":"socket","des":["The resource pointed to by `raw` must remain open for the duration of the returned `BorrowedSocket`."]}],"https://doc.rust-lang.org/std/os/unix/net/struct.UnixListener.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/std/fs/struct.File.html#method.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > u32::MAX` or `self - rhs < u32::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.drop_in_place":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Freed","f":"self","des":["Executes the destructor (if any) of the pointed-to value."]},{"sp":"Initialized","f":"self","des":["The value `self` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned, even if `T` has size 0.","Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > i32::MAX` or `self - rhs < i32::MIN`."]}],"https://doc.rust-lang.org/std/alloc/struct.System.html#method.realloc":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size.","`layout` must be the same layout that was used to allocate that block of memory."]},{"sp":"Bounded","f":"new_size","des":["`new_size` must be greater than zero.","`new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow `isize::MAX`."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must be currently allocated via this allocator."]},{"sp":"Freed","f":"ptr","des":["If this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory may or may not be initialized."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_ref-1":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_slice":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Bounded","f":"self","des":["The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"self","des":["The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Layout","f":"self","des":["The pointer must be aligned even for zero-length slices."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.write_unaligned":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/intrinsics/fn.const_allocate.html":[{"sp":"Bounded","f":"align","des":["`align` argument must be a power of two."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.split_at_unchecked":[{"sp":"Bounded","f":"mid","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used. The caller has to ensure that `0 <= mid <= self.len()`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.sub_ptr-1":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`.","The distance between the pointers must be non-negative (`self` >= `origin`)."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/hint/fn.unreachable_unchecked.html":[{"sp":"Unreachable","f":"NULL","des":["Reaching this function is Undefined Behavior.","It will safely panic in case it is actually reached at runtime."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI8.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/cell/struct.RefCell.html#method.try_borrow_unguarded":[{"sp":"Aliased","f":"retval","des":["Mutably borrowing the `RefCell` while the reference returned by this method is alive is undefined behaviour."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > u16::MAX` or `self * rhs < u16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.copy_from":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Allocated","f":"src","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"src","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]},{"sp":"Untyped","f":"src","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_offset_from-1":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > i64::MAX` or `self * rhs < i64::MIN`."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.decrement_strong_count":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method."]},{"sp":"Freed","f":"ptr","des":["This method can be used to release the final `Rc` and backing storage, but should not be called after the final `Rc` has been released."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Rc::into_raw`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read_volatile-1":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`.","However, storing non-`Copy` types in volatile memory is almost certainly incorrect."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU128.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > u128::MAX`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU16.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/convert/trait.FloatToInt.html":[{"sp":"Bounded","f":"self","des":["The value must not be `NaN`.","The value must not be infinite.","The value must be representable in the return type `Int`, after truncating off its fractional part."]}],"https://doc.rust-lang.org/core/ops/struct.RangeToInclusive.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.char.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `char::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `i16::MAX`."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > i8::MAX` or `self - rhs < i8::MIN`."]}],"https://doc.rust-lang.org/core/io/struct.BorrowedBuf.html#method.set_init":[{"sp":"Initialized","f":"self","des":["The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized."]}],"https://doc.rust-lang.org/core/ops/struct.RangeToInclusive.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.align_to":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"Initialized","f":"retval","des":["Both the argument and the result must be valid at their given type."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `T` and `U`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"self","des":["Both the `T` and the `U` must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"self","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `T` or `U` contain padding, that padding is not guaranteed to be preserved by transmute.","This method has no purpose when either input element `T` or output element `U` are zero-sized and will return the original slice without splitting anything.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `u8::MAX`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.offset_from":[{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.array_assume_init":[{"sp":"Initialized","f":"array","des":["It is up to the caller to guarantee that all elements of the array are in an initialized state."]}],"https://doc.rust-lang.org/core/intrinsics/fn.ctlz_nonzero.html":[{"sp":"Bounded","f":"x","des":["Like `ctlz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.assume_init":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU64.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU8.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > u8::MAX`."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.align_to_mut":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"Initialized","f":"retval","des":["Both the argument and the result must be valid at their given type."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `T` and `U`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"self","des":["Both the `T` and the `U` must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"self","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `T` or `U` contain padding, that padding is not guaranteed to be preserved by transmute.","This method has no purpose when either input element `T` or output element `U` are zero-sized and will return the original slice without splitting anything.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.downcast_unchecked":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html#tymethod.dealloc":[{"sp":"Layout","f":"layout","des":["`layout` must be the same layout that was used to allocate that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/alloc/ffi/struct.CString.html#method.from_raw":[{"sp":"Allocated","f":"ptr","des":["The raw pointer must point to a block of memory allocated by the global allocator.","Other usage (trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption."]},{"sp":"Initialized","f":"ptr","des":["Owned, C-compatible, nul-terminated string with no nul bytes in the middle.","This should only ever be called with a pointer that was earlier obtained by calling `CString::into_raw`.","The recomputed length must match the original length from the `CString::into_raw` call. This means the `CString::into_raw/from_raw` methods should not be used when passing the string to C functions that can modify the string's length."]},{"sp":"DualOwned","f":"retval","des":["Retakes ownership of a `CString` that was transferred to C via `CString::into_raw`."]}],"https://doc.rust-lang.org/core/ptr/fn.copy_nonoverlapping.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/core/mem/fn.transmute_copy.html":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"DualOwned","f":"retval","des":["It will also unsafely create a copy of the contained value instead of moving out of `src`."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"src","des":["Both the argument and the result must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"src","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU32.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > u32::MAX`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["The pointer must point to an initialized instance of `T`."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.downcast_unchecked-1":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/primitive.char.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `char::MAX`."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > u32::MAX` or `self + rhs < u32::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `u64::MIN`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.increment_strong_count_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Arc::into_raw`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.ptr_offset_from_unsigned.html":[{"sp":"Allocated","f":"base","des":[""]},{"sp":"Dereferencable","f":"base","des":["`base` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"ptr","des":[""]},{"sp":"Bounded","f":"ptr","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`.","The distance between the pointers must be non-negative (`ptr` >= `base`)."]},{"sp":"Dereferencable","f":"ptr","des":["`ptr` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"EST","f":"ptr","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/mem/fn.align_of_val_raw.html":[{"sp":"Bounded","f":"val","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]},{"sp":"Layout","f":"val","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroUsize.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > usize::MAX`."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `i32::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > u16::MAX` or `self - rhs < u16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > u8::MAX` or `self * rhs < u8::MIN`."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > usize::MAX` or `self - rhs < usize::MIN`."]}],"https://doc.rust-lang.org/core/ptr/fn.swap_nonoverlapping.html":[{"sp":"Allocated","f":"x","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"x","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `x` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `y` with the same size."]},{"sp":"Layout","f":"x","des":["`x` must be properly aligned."]},{"sp":"Untyped","f":"x","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"y","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"y","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `x` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `y` with the same size."]},{"sp":"Layout","f":"y","des":["`y` must be properly aligned."]},{"sp":"Untyped","f":"y","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/ptr/fn.write_volatile.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.byte_sub":[{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/intrinsics/fn.fdiv_fast.html":[{"sp":"Bounded","f":"x","des":["Float division that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.copy_to":[{"sp":"Allocated","f":"dest","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `usize::MAX`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.read":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/ops/struct.Range.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.sub_ptr":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`.","The distance between the pointers must be non-negative (`self` >= `subtracted`)."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]},{"sp":"Allocated","f":"subtracted","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"subtracted","des":["`subtracted` must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/result/enum.Result.html#method.unwrap_unchecked":[{"sp":"Unreachable","f":"self","des":["Calling this method on an `Err` is undefined behavior."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `isize::MIN`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.from_raw":[{"sp":"Allocated","f":"ptr","des":["The raw pointer must point to a block of memory allocated by the global allocator."]},{"sp":"Initialized","f":"ptr","des":["The raw pointer must have been previously returned by a call to `Arc<U>::into_raw`.","Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types."]},{"sp":"Layout","f":"ptr","des":["`Arc<U>::into_raw` where `U` must have the same size and alignment as `T`."]},{"sp":"DualOwned","f":"retval","des":["The user of `from_raw` has to make sure a specific value of `T` is only dropped once."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_ref":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.as_chunks_unchecked":[{"sp":"Bounded","f":"self","des":["The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).","`N != 0`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_ref":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["The pointer must point to an initialized instance of `T`."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_add":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.copy_from_nonoverlapping":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Allocated","f":"src","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `src` with the same size."]},{"sp":"DualOwned","f":"src","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]},{"sp":"Untyped","f":"src","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/slice/trait.SliceIndex.html#tymethod.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU16.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicU16>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.HandleOrInvalid.html#method.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["The passed handle value must either satisfy the safety requirements of `FromRawHandle::from_raw_handle` (below), or be `INVALID_HANDLE_VALUE` (-1).","`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.get_mut_unchecked":[{"sp":"Aliased","f":"retval","des":["If any other `Rc` or `Weak` pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this `Rc` (including lifetimes)."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.assume_init-1":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/std/os/fd/struct.OwnedFd.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The resource pointed to by `fd` must be open and suitable for assuming ownership. The resource must not require any cleanup other than `close`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.from_raw_in":[{"sp":"Allocated","f":"ptr","des":["The raw pointer must point to a block of memory allocated by `alloc` in the provided allocator."]},{"sp":"Initialized","f":"ptr","des":["The raw pointer must have been previously returned by a call to `Arc<U>::into_raw`.","Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types."]},{"sp":"Layout","f":"ptr","des":["`Arc<U>::into_raw` where `U` must have the same size and alignment as `T`."]},{"sp":"DualOwned","f":"retval","des":["The user of `from_raw` has to make sure a specific value of `T` is only dropped once."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.assume_init-1":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_mut":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state."]}],"https://doc.rust-lang.org/core/io/struct.BorrowedCursor.html#method.set_init":[{"sp":"Initialized","f":"self","des":["The caller must ensure that the first `n` bytes of the buffer have already been initialized."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > isize::MAX` or `self + rhs < isize::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.sub_ptr":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`.","The distance between the pointers must be non-negative (`self` >= `origin`)."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/primitive.f64.html#method.to_int_unchecked":[{"sp":"Bounded","f":"self","des":["The value must not be `NaN`.","The value must not be infinite.","The value must be representable in the return type `Int`, after truncating off its fractional part."]}],"https://doc.rust-lang.org/core/ops/struct.RangeTo.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/ptr/fn.copy.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/core/slice/fn.from_mut_ptr_range.html#":[{"sp":"Allocated","f":"range","des":["The `start` pointer of the range must be non-null even for zero-length slices.","The `end` pointer of the range must be non-null even for zero-length slices."]},{"sp":"Bounded","f":"range","des":["The total length of the `range` must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"range","des":["The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Initialized","f":"range","des":["The range must contain `N` consecutive properly initialized values of type `T`."]},{"sp":"Layout","f":"range","des":["The `start` pointer of the range must be properly aligned to the first element of a slice.","The `end` pointer of the range must be to one past the last element.","This function panics if `T` is a Zero-Sized Type (ZST)."]},{"sp":"Aliased","f":"retval","des":["The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`.","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > u128::MAX` or `self * rhs < u128::MIN`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI64.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.tuple.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > u64::MAX` or `self - rhs < u64::MIN`."]}],"https://doc.rust-lang.org/core/mem/fn.zeroed.html":[{"sp":"Untyped","f":"retval","des":["The padding byte is not necessarily zeroed. There is no guarantee that an all-zero byte-pattern represents a valid value of some type `T`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU128.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > i64::MAX` or `self + rhs < i64::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.new_unchecked":[{"sp":"Allocated","f":"ptr","des":["`ptr` must be non-null."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.offset_from-1":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.read_volatile":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`.","However, storing non-`Copy` types in volatile memory is almost certainly incorrect."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU32.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > u32::MAX`."]}],"https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.get_many_unchecked_mut":[{"sp":"Aliased","f":"retval","des":["Calling this method with overlapping keys is undefined behavior even if the resulting references are not used."]}],"https://doc.rust-lang.org/core/ops/struct.RangeToInclusive.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ops/struct.Range.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/std/net/struct.TcpListener.html#method.from_raw_socket":[{"sp":"SystemIO","f":"sock","des":["`sock` must be an owned socket; in particular, it must be open.","`sock` must be a socket that may be freed via `closesocket`."]}],"https://doc.rust-lang.org/std/os/fd/trait.FromRawFd.html#tymethod.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.increment_strong_count_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Rc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Rc::into_raw`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.copy_nonoverlapping.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.from_raw_parts":[{"sp":"Bounded","f":"capacity","des":["The size of `T` times the `capacity` (ie. the allocated size in bytes) needs to be the same size as the pointer was allocated with.","`capacity` needs to be the capacity that the pointer was allocated with.","`length` needs to be less than or equal to `capacity`."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must have been allocated using the global allocator, such as via the `alloc::alloc` function."]},{"sp":"Bounded","f":"ptr","des":["The allocated size in bytes must be no larger than `isize::MAX`."]},{"sp":"Initialized","f":"ptr","des":["The first `length` values must be properly initialized values of type `T`."]},{"sp":"Layout","f":"ptr","des":["`T` needs to have the same alignment as what `ptr` was allocated with."]},{"sp":"DualOwned","f":"retval","des":["The ownership of `ptr` is effectively transferred to the `Vec<T>` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.assume_init":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI16.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > i16::MAX`, or `self * rhs < i16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `u64::MAX`."]}],"https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.from_raw_socket":[{"sp":"SystemIO","f":"sock","des":["`sock` must be an owned socket; in particular, it must be open.","`sock` must be a socket that may be freed via `closesocket`."]}],"https://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.get_unchecked":[{"sp":"Bounded","f":"index","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used."]},{"sp":"Dereferencable","f":"self","des":["When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.str.html#method.get_unchecked":[{"sp":"Bounded","f":"i","des":["The starting index must not exceed the ending index.","Indexes must be within bounds of the original slice."]},{"sp":"Initialized","f":"i","des":["Indexes must lie on UTF-8 sequence boundaries."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_offset_from":[{"sp":"Allocated","f":"origin","des":[""]},{"sp":"Dereferencable","f":"origin","des":["`origin` must be either in bounds or one byte past the end of the same allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The distance between the pointers, in bytes, cannot overflow an `isize`.","The distance between the pointers, in bytes, must be an exact multiple of the size of `T`."]},{"sp":"Dereferencable","f":"self","des":["`self` must be either in bounds or one byte past the end of the same allocated object.","Both pointers must be derived from a pointer to the same object."]},{"sp":"Layout","f":"self","des":["This function panics if `T` is a Zero-Sized Type (ZST)."]}],"https://doc.rust-lang.org/core/intrinsics/fn.unchecked_add.html":[{"sp":"Bounded","f":"x","des":["Returns the result of an unchecked addition, resulting in undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_mut_unchecked":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > isize::MAX` or `self - rhs < isize::MIN`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.assume.html":[{"sp":"Bounded","f":"b","des":["If the condition is false, the behavior is undefined."]}],"https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#":[{"sp":"Allocated","f":"data","des":["`data` must be non-null even for zero-length slices."]},{"sp":"Dereferencable","f":"data","des":["The entire memory range (`len * mem::size_of::<T>()` bytes) of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Initialized","f":"data","des":["`data` must point to `len` consecutive properly initialized values of type `T`."]},{"sp":"Layout","f":"data","des":["`data` must be aligned even for zero-length slices."]},{"sp":"Bounded","f":"len","des":["The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Aliased","f":"retval","des":["The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`.","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicI16.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicI16>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > i16::MAX` or `self * rhs < i16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.offset":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/std/fs/struct.File.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/core/mem/fn.size_of_val_raw.html":[{"sp":"Bounded","f":"val","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]},{"sp":"Layout","f":"val","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > i128::MAX` or `self - rhs < i128::MIN`."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU32.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicU32>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI32.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `i8::MAX`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.sub-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"index","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/std/os/linux/process/struct.PidFd.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/alloc/str/fn.from_boxed_utf8_unchecked.html":[{"sp":"Initialized","f":"v","des":["Converts a boxed slice of bytes to a boxed string slice without checking that the string contains valid UTF-8."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.from_raw_in":[{"sp":"Allocated","f":"ptr","des":["The raw pointer must point to a block of memory allocated by `alloc` in the provided allocator."]},{"sp":"Initialized","f":"ptr","des":["The raw pointer must have been previously returned by a call to `Rc<U>::into_raw`.","Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types."]},{"sp":"Layout","f":"ptr","des":["`Rc<U>::into_raw` where `U` must have the same size and alignment as `T`."]},{"sp":"DualOwned","f":"retval","des":["The user of `from_raw` has to make sure a specific value of `T` is only dropped once."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `i128::MAX`."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.get_unchecked":[{"sp":"Bounded","f":"index","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.copy_to_nonoverlapping":[{"sp":"Allocated","f":"dest","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.from_raw":[{"sp":"DualOwned","f":"retval","des":["After calling this function, the raw pointer is owned by the resulting `Box`. A double-free may occur if the function is called twice on the same raw pointer."]},{"sp":"Allocated","f":"self","des":["For non-zero-sized values, a `Box` will use the Global allocator for its allocation.","For zero-sized values, the `Box` pointer still has to be valid for reads and writes (always be non-null pointers)."]},{"sp":"Initialized","f":"self","des":["Recreate a `Box` which was previously converted to a raw pointer using `Box::into_raw`.","It is valid to convert both ways between a `Box` and a raw pointer allocated with the Global allocator, given that the `Layout` used with the allocator is correct for the type."]},{"sp":"Layout","f":"self","des":["The `Box` pointer has to be sufficiently aligned (always be fully aligned)."]}],"https://doc.rust-lang.org/std/os/windows/io/trait.FromRawHandle.html#tymethod.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.read_unaligned":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]}],"https://doc.rust-lang.org/core/mem/struct.ManuallyDrop.html#method.take":[{"sp":"DualOwned","f":"retval","des":["This function semantically moves out the contained value without preventing further usage, leaving the state of this container unchanged. It is your responsibility to ensure that this `ManuallyDrop` is not used again."]}],"https://doc.rust-lang.org/std/os/windows/io/trait.FromRawSocket.html#tymethod.from_raw_socket":[{"sp":"SystemIO","f":"sock","des":["`sock` must be an owned socket; in particular, it must be open.","`sock` must be a socket that may be freed via `closesocket`."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.transmute.html":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"Initialized","f":"retval","des":["Both the argument and the result must be valid at their given type."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"src","des":["Both the argument and the result must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"src","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU8.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > u8::MAX`."]}],"https://doc.rust-lang.org/core/array/struct.IntoIter.html#method.new_unchecked":[{"sp":"Initialized","f":"buffer","des":["The `buffer[initialized]` elements must all be initialized."]},{"sp":"Bounded","f":"initialized","des":["The range must be in-bounds for the buffer, with `initialized.end <= N`.","The range must be canonical, with `initialized.start` <= `initialized.end`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU16.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > u16::MAX`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFrom.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_add-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/alloc/string/struct.String.html#method.from_utf8_unchecked":[{"sp":"Initialized","f":"bytes","des":["It does not check that the bytes passed to it are valid UTF-8."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU128.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > u128::MAX`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Weak.html#method.from_raw":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference."]},{"sp":"DualOwned","f":"retval","des":["It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_slice-1":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Bounded","f":"self","des":["The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"self","des":["The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Layout","f":"self","des":["The pointer must be aligned even for zero-length slices."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU64.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > u64::MAX`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.split_at_mut":[{"sp":"Bounded","f":"mid","des":["Panics if `mid` > `len`.","`mid` must be in-bounds of the underlying allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Dereferencable","f":"self","des":["`self` must be dereferenceable and span a single allocation that is at least `mid * size_of::<T>()` bytes long."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.add":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html#method.realloc":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size.","`layout` must be the same layout that was used to allocate that block of memory."]},{"sp":"Bounded","f":"new_size","des":["`new_size` must be greater than zero.","`new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow `isize::MAX`."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must be currently allocated via this allocator."]},{"sp":"Freed","f":"ptr","des":["If this returns a non-null pointer, then ownership of the memory block referenced by `ptr` has been transferred to this allocator."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory may or may not be initialized."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.swap":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Untyped","f":"self","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Layout","f":"selfx","des":["`self` must be properly aligned."]},{"sp":"Allocated","f":"with","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"with","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"with","des":["`with` must be properly aligned."]},{"sp":"Untyped","f":"with","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/std/process/struct.Stdio.html#method.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicU64>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.drop_in_place":[{"sp":"Allocated","f":"self","des":["`self` must be nonnull, even if T has size 0.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Freed","f":"self","des":["Executes the destructor (if any) of the pointed-to value."]},{"sp":"Initialized","f":"self","des":["The value `self` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned, even if `T` has size 0.","Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`."]}],"https://doc.rust-lang.org/core/pin/struct.Pin.html#method.map_unchecked":[{"sp":"Pinned","f":"retval","des":["The data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.slice_assume_init_mut":[{"sp":"Initialized","f":"slice","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state."]}],"https://doc.rust-lang.org/core/intrinsics/fn.volatile_copy_memory.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.from_raw_socket":[{"sp":"SystemIO","f":"sock","des":["`sock` must be an owned socket; in particular, it must be open.","`sock` must be a socket that may be freed via `closesocket`."]}],"https://doc.rust-lang.org/core/ptr/fn.replace.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"dst","des":["`dst` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"src","des":["Neither value is dropped."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > i128::MAX` or `self + rhs < i128::MIN`."]}],"https://doc.rust-lang.org/core/pin/struct.Pin.html#method.map_unchecked_mut":[{"sp":"Pinned","f":"retval","des":["The data you return will not move so long as the argument value does not move (for example, because it is one of the fields of that value), and also that you do not move out of the argument you receive to the interior function."]}],"https://doc.rust-lang.org/core/primitive.char.html#method.from_u32_unchecked":[{"sp":"Initialized","f":"i","des":["Not all valid `u32`s are valid `char`s, it may construct invalid `char` values."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI16.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > i8::MAX` or `self + rhs < i8::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > u64::MAX` or `self * rhs < u64::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.write":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicI8.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicI8>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_read":[{"sp":"DualOwned","f":"retval","des":["This function creates a bitwise copy of the contents, regardless whether the contained type implements the `Copy` trait or not. When using multiple copies of the data (by calling `assume_init_read` multiple times, or first calling `assume_init_read` and then `assume_init`), it is your responsibility to ensure that data may indeed be duplicated."]},{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_drop":[{"sp":"Freed","f":"self","des":["Drops the contained value in place."]},{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state.","All additional invariants of the type `T` must be satisfied, as the `Drop` implementation of `T` (or its members) may rely on this."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_ref-1":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["The pointer must point to an initialized instance of `T`."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.cttz_nonzero.html":[{"sp":"Bounded","f":"x","des":["Like `cttz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`."]}],"https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html#tymethod.alloc":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory may or may not be initialized."]}],"https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.set_len":[{"sp":"Bounded","f":"new_len","des":["`new_len` must be less than or equal to `capacity()`."]},{"sp":"Initialized","f":"self","des":["The elements at `old_len..new_len` must be initialized."]},{"sp":"Leaked","f":"self","des":["There maybe a memory leak since the inner vectors were not freed prior to the `set_len` call."]}],"https://doc.rust-lang.org/core/intrinsics/fn.unaligned_volatile_load.html":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `src` can violate memory safety. Note that assigning to `src` counts as a use because it will attempt to drop the value at `src`.","However, storing non-`Copy` types in volatile memory is almost certainly incorrect."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"src","des":["`src` must point to a properly initialized value of type `T`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroIsize.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > isize::MAX`, or `self * rhs < isize::MIN`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFull.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"index","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting pointer is not used."]},{"sp":"Dereferencable","f":"self","des":["When `self` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.increment_strong_count":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) for the duration of this method."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Arc::into_raw`."]}],"https://doc.rust-lang.org/core/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked":[{"sp":"Initialized","f":"bytes","des":["The provided slice must be nul-terminated and not contain any interior nul bytes."]}],"https://doc.rust-lang.org/core/intrinsics/fn.fsub_fast.html":[{"sp":"Bounded","f":"x","des":["Float subtraction that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > isize::MAX` or `self * rhs < isize::MIN`."]}],"https://doc.rust-lang.org/core/primitive.str.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"i","des":["The starting index must not exceed the ending index.","Indexes must be within bounds of the original slice."]},{"sp":"Initialized","f":"i","des":["Indexes must lie on UTF-8 sequence boundaries."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.replace":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"src","des":["Neither value is dropped."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU8.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicU8>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicUsize.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicUsize>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/std/alloc/struct.System.html#method.dealloc":[{"sp":"Layout","f":"layout","des":["`layout` must be the same layout that was used to allocate that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]}],"https://doc.rust-lang.org/alloc/ffi/struct.CString.html#method.from_vec_unchecked":[{"sp":"Initialized","f":"v","des":["This method is equivalent to `CString::new` except that no runtime assertion is made that `v` contains no 0 bytes, and it requires an actual byte vector, not anything that can be converted to one with `Into`."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/alloc/string/struct.String.html#method.as_mut_vec":[{"sp":"Untyped","f":"self","des":["The returned &mut Vec allows writing bytes which are not valid UTF-8."]}],"https://doc.rust-lang.org/alloc/rc/struct.Weak.html#method.from_raw_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by `alloc` in the provided allocator."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference."]},{"sp":"DualOwned","f":"retval","des":["It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.slice_assume_init_ref":[{"sp":"Initialized","f":"slice","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` elements really are in an initialized state."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > u128::MAX` or `self + rhs < u128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.from_raw":[{"sp":"Allocated","f":"ptr","des":["The raw pointer must point to a block of memory allocated by the global allocator."]},{"sp":"Initialized","f":"ptr","des":["The raw pointer must have been previously returned by a call to `Rc<U>::into_raw`.","Note that if `U` is not `T` but has the same size and alignment, this is basically like transmuting references of different types."]},{"sp":"Layout","f":"ptr","des":["`Rc<U>::into_raw` where `U` must have the same size and alignment as `T`."]},{"sp":"DualOwned","f":"retval","des":["The user of `from_raw` has to make sure a specific value of `T` is only dropped once."]}],"https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU16.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > u16::MAX`."]}],"https://doc.rust-lang.org/core/char/fn.from_u32_unchecked.html":[{"sp":"Initialized","f":"i","des":["Not all valid `u32`s are valid `char`s, it may construct invalid `char` values."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.downcast_unchecked":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeTo.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.i128.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `i128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read_unaligned":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_uninit_ref":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.offset":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU8.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI64.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > i64::MAX`, or `self * rhs < i64::MIN`."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.decrement_strong_count":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method."]},{"sp":"Freed","f":"ptr","des":["This method can be used to release the final `Arc` and backing storage, but should not be called after the final `Arc` has been released."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Arc::into_raw`."]}],"https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.for_value_raw":[{"sp":"Bounded","f":"t","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]},{"sp":"Layout","f":"t","des":["If the unsized tail of `T` is a slice, then the length of the slice tail must be an initialized integer, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`.","If the unsized tail of `T` is a trait object, then the vtable part of the pointer must point to a valid vtable for the type `T` acquired by an unsizing coercion, and the size of the entire value (dynamic tail length + statically sized prefix) must fit in `isize`."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > u32::MAX` or `self * rhs < u32::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.Alignment.html#method.new_unchecked":[{"sp":"Bounded","f":"align","des":["`align` must be a power of two.","Equivalently, it must be `1 << exp` for some exp in `0..usize::BITS`. It must not be zero."]}],"https://doc.rust-lang.org/core/primitive.u64.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > u64::MAX` or `self + rhs < u64::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.write_volatile":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicI64.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicI64>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_mut_unchecked-1":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_to_nonoverlapping":[{"sp":"Allocated","f":"dest","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.decrement_strong_count_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by allocated by `alloc` in the provided allocator."]},{"sp":"Bounded","f":"ptr","des":["The associated `Arc` instance must be valid (i.e. the strong count must be at least 1) when invoking this method."]},{"sp":"Freed","f":"ptr","des":["This method can be used to release the final `Arc` and backing storage, but should not be called after the final `Arc` has been released."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have been obtained through `Arc::into_raw`."]}],"https://doc.rust-lang.org/core/ops/struct.Range.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_to":[{"sp":"Allocated","f":"dest","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.swap_unchecked":[{"sp":"Bounded","f":"a","des":["Calling this method with an out-of-bounds index is undefined behavior. The caller has to ensure that `a < self.len()`."]},{"sp":"Bounded","f":"b","des":["Calling this method with an out-of-bounds index is undefined behavior. The caller has to ensure that `b < self.len()`."]}],"https://doc.rust-lang.org/std/os/fd/struct.BorrowedFd.html#method.borrow_raw":[{"sp":"Bounded","f":"fd","des":["The resource pointed to by `fd` must not have the value `-1`."]},{"sp":"SystemIO","f":"fd","des":["The resource pointed to by `fd` must remain open for the duration of the returned `BorrowedFd`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFrom.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > u16::MAX` or `self + rhs < u16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > u8::MAX` or `self + rhs < u8::MIN`."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `u16::MAX`."]}],"https://doc.rust-lang.org/core/primitive.str.html#method.as_bytes_mut":[{"sp":"Initialized","f":"self","des":["The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying `str` is used."]}],"https://doc.rust-lang.org/alloc/string/struct.String.html#method.from_raw_parts":[{"sp":"Allocated","f":"buf","des":["The memory at `buf` needs to have been previously allocated by the same allocator the standard library uses."]},{"sp":"Initialized","f":"buf","des":["The first length bytes at `buf` need to be valid UTF-8."]},{"sp":"Layout","f":"buf","des":["The memory at buf is required alignment of exactly 1."]},{"sp":"Bounded","f":"capacity","des":["`capacity` needs to be the correct value."]},{"sp":"Bounded","f":"length","des":["`length` needs to be less than or equal to `capacity`."]},{"sp":"DualOwned","f":"retval","des":["The ownership of `buf` is effectively transferred to the `String` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU32.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `u128::MAX`."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicIsize.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicIsize>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/alloc/boxed/struct.Box.html#method.downcast_unchecked-2":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html#method.alloc_zeroed":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory is guaranteed to be initialized but may be untyped."]}],"https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.from_size_align_unchecked":[{"sp":"Bounded","f":"align","des":["`align` must not be zero.","`align` must be a power of two."]},{"sp":"Bounded","f":"size","des":["`size`, when rounded up to the nearest multiple of `align`, must not overflow `isize::MAX`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.raw_eq.html":[{"sp":"Initialized","f":"a","des":["It's UB to call this if any of the bytes in `*a` are uninitialized or carry a pointer value."]},{"sp":"Layout","f":"a","des":["Note that this is a stricter criterion than just the values being fully-initialized: if `T` has padding, it's UB to call this intrinsic."]},{"sp":"Initialized","f":"b","des":["It's UB to call this if any of the bytes in `*b` are uninitialized or carry a pointer value."]},{"sp":"Layout","f":"b","des":["Note that this is a stricter criterion than just the values being fully-initialized: if `T` has padding, it's UB to call this intrinsic."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > i32::MAX` or `self * rhs < i32::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.sub":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > i16::MAX` or `self - rhs < i16::MIN`."]}],"https://doc.rust-lang.org/std/os/fd/type.RawFd.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.write":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_uninit_slice_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Bounded","f":"self","des":["The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"self","des":["The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Layout","f":"self","des":["The pointer must be aligned even for zero-length slices."]}],"https://doc.rust-lang.org/core/primitive.str.html#method.slice_unchecked":[{"sp":"Bounded","f":"begin","des":["`begin` must not exceed `end`.","`begin` must be byte positions within the string slice."]},{"sp":"Initialized","f":"begin","des":["`begin` must lie on UTF-8 sequence boundaries."]},{"sp":"Bounded","f":"end","des":["`end` must be byte positions within the string slice."]},{"sp":"Initialized","f":"end","des":["`end` must lie on UTF-8 sequence boundaries."]}],"https://doc.rust-lang.org/std/process/struct.Stdio.html#method.from_raw_fd":[{"sp":"SystemIO","f":"fd","des":["The `fd` passed in must be an owned file descriptor; in particular, it must be open."]}],"https://doc.rust-lang.org/core/primitive.isize.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `isize::MAX`."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > i16::MAX` or `self + rhs < i16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `i32::MAX`."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > i8::MAX` or `self * rhs < i8::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.as_ref":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Either the pointer is null or all of the following is true."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["The pointer must point to an initialized instance of `T`."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `u16::MAX`."]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_ref_unchecked-2":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFull.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/fn.drop_in_place.html":[{"sp":"Allocated","f":"to_drop","des":["`to_drop` must be nonnull, even if T has size 0.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"to_drop","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Freed","f":"to_drop","des":["Executes the destructor (if any) of the pointed-to value."]},{"sp":"Initialized","f":"to_drop","des":["The value `to_drop` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped."]},{"sp":"Layout","f":"to_drop","des":["`to_drop` must be properly aligned, even if `T` has size 0.","Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`."]}],"https://doc.rust-lang.org/core/ops/struct.Range.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["The pointer must point to an initialized instance of `T`."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_uninit_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["The pointer must be properly aligned."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicI32.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicI32>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI128.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > i128::MAX`, or `self * rhs < i128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > usize::MAX` or `self + rhs < usize::MIN`."]}],"https://doc.rust-lang.org/core/slice/trait.SliceIndex.html#tymethod.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/str/fn.from_utf8_unchecked.html":[{"sp":"Initialized","f":"v","des":["The bytes passed in must be valid UTF-8."]}],"https://doc.rust-lang.org/core/io/struct.BorrowedCursor.html#method.advance":[{"sp":"Initialized","f":"self","des":["The caller must ensure that the first `n` bytes of the cursor have been properly initialised."]}],"https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn_unchecked":[{"sp":"Aliased","f":"retval","des":["The spawned thread may outlive the caller. The caller has to ensure that the spawned thread does not outlive any references in the supplied thread closure and its return type."]},{"sp":"Initialized","f":"self","des":["Panics if a thread name was set and it contained null bytes."]}],"https://doc.rust-lang.org/alloc/vec/struct.Vec.html#method.from_raw_parts_in":[{"sp":"Bounded","f":"capacity","des":["The size of `T` times the `capacity` (ie. the allocated size in bytes) needs to be the same size as the pointer was allocated with.","`capacity` needs to be the capacity that the pointer was allocated with.","`length` needs to be less than or equal to `capacity`."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must be currently allocated via the given allocator `alloc`."]},{"sp":"Bounded","f":"ptr","des":["The allocated size in bytes must be no larger than `isize::MAX`."]},{"sp":"Initialized","f":"ptr","des":["The first `length` values must be properly initialized values of type `T`."]},{"sp":"Layout","f":"ptr","des":["`T` needs to have the same alignment as what `ptr` was allocated with."]},{"sp":"DualOwned","f":"retval","des":["The ownership of `ptr` is effectively transferred to the `Vec<T>` which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function."]}],"https://doc.rust-lang.org/core/intrinsics/fn.unchecked_mul.html":[{"sp":"Bounded","f":"x","des":["Returns the result of an unchecked multiplication, resulting in undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`."]}],"https://doc.rust-lang.org/core/alloc/trait.Allocator.html#method.grow":[{"sp":"Bounded","f":"new_layout","des":["`new_layout.size()` must be greater than or equal to `old_layout.size()`."]},{"sp":"Layout","f":"old_layout","des":["`old_layout` must fit that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]},{"sp":"Freed","f":"ptr","des":["If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. "]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory may or may not be initialized."]}],"https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/mem/struct.ManuallyDrop.html#method.drop":[{"sp":"Freed","f":"slot","des":["This function runs the destructor of the contained value. The zombie value should not be exposed to safe code after been dropped, and this function should not be called more than once."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI8.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > i8::MAX`, or `self * rhs < i8::MIN`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeTo.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.str.html#method.slice_mut_unchecked":[{"sp":"Bounded","f":"begin","des":["`begin` must not exceed `end`.","`begin` must be byte positions within the string slice."]},{"sp":"Initialized","f":"begin","des":["`begin` must lie on UTF-8 sequence boundaries."]},{"sp":"Bounded","f":"end","des":["`end` must be byte positions within the string slice."]},{"sp":"Initialized","f":"end","des":["`end` must lie on UTF-8 sequence boundaries."]}],"https://doc.rust-lang.org/alloc/sync/struct.Weak.html#method.from_raw_in":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by `alloc` in the provided allocator."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference."]},{"sp":"DualOwned","f":"retval","des":["It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`."]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_mut_unchecked-2":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroI128.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFrom.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ops/struct.RangeToInclusive.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.f32.html#method.to_int_unchecked":[{"sp":"Bounded","f":"self","des":["The value must not be `NaN`.","The value must not be infinite.","The value must be representable in the return type `Int`, after truncating off its fractional part."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `u128::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.write_volatile":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/pin/struct.Pin.html#method.get_unchecked_mut":[{"sp":"Pinned","f":"retval","des":["You will never move the data out of the mutable reference you receive when you call this function, so that the invariants on the `Pin` type can be upheld."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_offset-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_to-1":[{"sp":"Allocated","f":"dest","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/alloc/rc/struct.Weak.html#method.from_raw":[{"sp":"Allocated","f":"ptr","des":["`ptr` must point to a block of memory allocated by the global allocator."]},{"sp":"Initialized","f":"ptr","des":["The pointer must have originated from the `Weak::into_raw` and must still own its potential weak reference."]},{"sp":"DualOwned","f":"retval","des":["It takes ownership of one weak reference. This can be used to deallocate the weak count by dropping the `Weak<T>`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_to_nonoverlapping-1":[{"sp":"Allocated","f":"dest","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dest","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"DualOwned","f":"dest","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dest` can violate memory safety. Note that assigning to `*dest` counts as a use because it will attempt to drop the value at `*dest`."]},{"sp":"Layout","f":"dest","des":["`dest` must be properly aligned."]},{"sp":"Leaked","f":"dest","des":[""]},{"sp":"Untyped","f":"dest","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `self` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dest` with the same size."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFull.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.sub":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/alloc/ffi/struct.CString.html#method.from_vec_with_nul_unchecked":[{"sp":"Initialized","f":"v","des":["The given `Vec` must have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.byte_offset":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/slice/fn.from_ptr_range.html#":[{"sp":"Allocated","f":"range","des":["The `start` pointer of the range must be non-null even for zero-length slices.","The `end` pointer of the range must be non-null even for zero-length slices."]},{"sp":"Bounded","f":"range","des":["The total length of the `range` must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"range","des":["The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Initialized","f":"range","des":["The range must contain `N` consecutive properly initialized values of type `T`."]},{"sp":"Layout","f":"range","des":["The `start` pointer of the range must be properly aligned to the first element of a slice.","The `end` pointer of the range must be to one past the last element.","This function panics if `T` is a Zero-Sized Type (ZST)."]},{"sp":"Aliased","f":"retval","des":["The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`.","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroU64.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self * rhs > u64::MAX`."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicPtr.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicPtr<T>>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.unchecked_mul":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self * rhs > usize::MAX` or `self * rhs < usize::MIN`."]}],"https://doc.rust-lang.org/core/ptr/fn.swap.html":[{"sp":"Allocated","f":"x","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"x","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"x","des":["`x` must be properly aligned."]},{"sp":"Untyped","f":"x","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"y","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"y","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"y","des":["`y` must be properly aligned."]},{"sp":"Untyped","f":"y","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.write_bytes.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["Additionally, note that changing `dst` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.get_many_unchecked_mut":[{"sp":"Bounded","f":"index","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]}],"https://doc.rust-lang.org/std/alloc/struct.System.html#method.alloc_zeroed":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory is guaranteed to be initialized but may be untyped."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.OwnedHandle.html#method.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.copy.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_offset":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.i16.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `i16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.add-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/alloc/sync/struct.Arc.html#method.get_mut_unchecked":[{"sp":"Aliased","f":"retval","des":["If any other `Arc` or `Weak` pointers to the same allocation exist, then they must not be dereferenced or have active borrows for the duration of the returned borrow, and their inner type must be exactly the same as the inner type of this `Arc` (including lifetimes)."]}],"https://doc.rust-lang.org/core/intrinsics/fn.frem_fast.html":[{"sp":"Bounded","f":"x","des":["Float remainder that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.split_at_mut_unchecked":[{"sp":"Bounded","f":"mid","des":["Panics if `mid` > `len`.","`mid` must be in-bounds of the underlying allocated object."]},{"sp":"Allocated","f":"self","des":[""]},{"sp":"Dereferencable","f":"self","des":["`self` must be dereferenceable and span a single allocation that is at least `mid * size_of::<T>()` bytes long."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_sub-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroUsize.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["The behaviour is undefined as soon as `self + rhs > usize::MAX`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.transmute_unchecked.html":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"Initialized","f":"retval","des":["Both the argument and the result must be valid at their given type."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"src","des":["Both the argument and the result must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"src","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.byte_sub":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.copy_from":[{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"DualOwned","f":"src","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]},{"sp":"Untyped","f":"src","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/result/enum.Result.html#method.unwrap_err_unchecked":[{"sp":"Unreachable","f":"self","des":["Calling this method on an `Ok` is undefined behavior."]}],"https://doc.rust-lang.org/core/task/struct.Waker.html#method.from_raw":[{"sp":"Thread","f":"waker","des":["These functions must all be thread-safe (even though `RawWaker` is `!Send + !Sync`) because `Waker` is `Send + Sync`, and thus wakers may be moved to arbitrary threads or invoked by `&` reference."]}],"https://doc.rust-lang.org/core/pin/struct.Pin.html#method.into_inner_unchecked":[{"sp":"Pinned","f":"retval","des":["You will continue to treat the pointer `P` as pinned after you call this function, so that the invariants on the Pin type can be upheld. If the code using the resulting `P` does not continue to maintain the pinning invariants that is a violation of the API contract and may lead to undefined behavior in later (safe) operations."]}],"https://doc.rust-lang.org/core/ops/struct.RangeTo.html#method.get_unchecked_mut":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.u32.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `u32::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.unchecked_add":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self + rhs > i32::MAX` or `self + rhs < i32::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.swap":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Untyped","f":"self","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Layout","f":"selfx","des":["`self` must be properly aligned."]},{"sp":"Allocated","f":"with","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"with","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"with","des":["`with` must be properly aligned."]},{"sp":"Untyped","f":"with","des":["The operation is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `i64::MAX`."]}],"https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html#method.get_unchecked_mut-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.write_bytes":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"self","des":["`self` must be properly aligned."]},{"sp":"Leaked","f":"self","des":[""]},{"sp":"Untyped","f":"self","des":["Additionally, note that changing `self` in this way can easily lead to undefined behavior (UB) later if the written bytes are not a valid representation of some `T`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.drop_in_place.html":[{"sp":"Allocated","f":"to_drop","des":["`to_drop` must be nonnull, even if T has size 0.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"to_drop","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Freed","f":"to_drop","des":["Executes the destructor (if any) of the pointed-to value."]},{"sp":"Initialized","f":"to_drop","des":["The value `to_drop` points to must be valid for dropping, which may mean it must uphold additional invariants. These invariants depend on the type of the value being dropped."]},{"sp":"Layout","f":"to_drop","des":["`to_drop` must be properly aligned, even if `T` has size 0.","Unaligned values cannot be dropped in place, they must be copied to an aligned location first using `ptr::read_unaligned`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.unaligned_volatile_store.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Leaked","f":"dst","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/core/io/struct.BorrowedCursor.html#method.as_mut":[{"sp":"Initialized","f":"self","des":["The caller must not uninitialize any bytes in the initialized portion of the cursor."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `i64::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i64.html#method.unchecked_sub":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior when `self - rhs > i64::MAX` or `self - rhs < i64::MIN`."]}],"https://doc.rust-lang.org/core/ptr/fn.read_unaligned.html":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"src","des":["`src` must point to a properly initialized value of type `T`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_uninit_slice":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"self","des":["The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Layout","f":"self","des":["The pointer must be aligned even for zero-length slices."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.as_uninit_slice_mut":[{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get accessed (read or written) through any other pointer.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]},{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Bounded","f":"self","des":["The total size `ptr.len() * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Dereferencable","f":"self","des":["The entire memory range of this slice (`ptr.len() * mem::size_of::<T>()` bytes) must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Layout","f":"self","des":["The pointer must be aligned even for zero-length slices."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.read_unaligned-1":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `self` can violate memory safety. Note that assigning to `self` counts as a use because it will attempt to drop the value at `self`."]},{"sp":"Allocated","f":"self","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"self","des":["`self` must point to a properly initialized value of type `T`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.fmul_fast.html":[{"sp":"Bounded","f":"x","des":["Float multiplication that allows optimizations based on algebraic rules. The calculated result cannot overflow `T::MAX` or `T::MIN`."]}],"https://doc.rust-lang.org/core/primitive.slice.html#method.split_at_mut_unchecked":[{"sp":"Bounded","f":"mid","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used. The caller has to ensure that `0 <= mid <= self.len()`."]}],"https://doc.rust-lang.org/core/primitive.u8.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `u8::MIN`."]}],"https://doc.rust-lang.org/core/ptr/struct.NonNull.html#method.write_unaligned":[{"sp":"Allocated","f":"self","des":["Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"self","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Leaked","f":"self","des":["This is safe, but it could leak allocations or resources, so care should be taken not to overwrite an object that should be dropped."]}],"https://doc.rust-lang.org/std/alloc/struct.System.html#method.alloc":[{"sp":"Layout","f":"layout","des":["`layout` has non-zero size."]},{"sp":"Freed","f":"retval","des":["Returning a null pointer indicates that either memory is exhausted."]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory may or may not be initialized."]}],"https://doc.rust-lang.org/core/ffi/struct.CStr.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["`ptr` must be non-null even for a zero-length cstr."]},{"sp":"Bounded","f":"ptr","des":["The nul terminator must be within `isize::MAX` from `ptr`."]},{"sp":"Dereferencable","f":"ptr","des":["The entire memory range of this `CStr` must be contained within a single allocated object!"]},{"sp":"Initialized","f":"ptr","des":["The memory pointed to by `ptr` must contain a valid nul terminator at the end of the string."]},{"sp":"Aliased","f":"retval","des":["The memory referenced by the returned `CStr` must not be mutated for the duration of lifetime `'a`.","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context."]}],"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html#method.from_ptr":[{"sp":"Allocated","f":"ptr","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"ptr","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Layout","f":"ptr","des":["`ptr` must be aligned to `align_of::<AtomicBool>()`."]},{"sp":"Thread","f":"ptr","des":["You must adhere to the Memory model for atomic accesses. In particular, it is not allowed to mix atomic and non-atomic accesses, or atomic accesses of different sizes, without synchronization."]},{"sp":"Aliased","f":"retval","des":["You must enforce Rust's aliasing rules. In particular, while this reference exists, the memory the pointer points to must not get mutated.","The returned lifetime `'a` is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data."]}],"https://doc.rust-lang.org/core/intrinsics/fn.const_deallocate.html":[{"sp":"Bounded","f":"align","des":["`align` argument must be a power of two."]}],"https://doc.rust-lang.org/core/intrinsics/fn.unchecked_sub.html":[{"sp":"Bounded","f":"x","des":["Returns the result of an unchecked subtraction, resulting in undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`."]}],"https://doc.rust-lang.org/core/intrinsics/fn.const_eval_select.html":[{"sp":"Bounded","f":"called_in_const","des":["The two functions must behave observably equivalent. Safe code in other crates may assume that calling a `const fn` at compile-time and at run-time produces the same result. A function that produces a different result when evaluated at run-time, or has any other observable side-effects, is unsound."]}],"https://doc.rust-lang.org/core/alloc/trait.Allocator.html#method.grow_zeroed":[{"sp":"Bounded","f":"new_layout","des":["`new_layout.size()` must be greater than or equal to `old_layout.size()`."]},{"sp":"Layout","f":"old_layout","des":["`old_layout` must fit that block of memory."]},{"sp":"Allocated","f":"ptr","des":["`ptr` must denote a block of memory currently allocated via this allocator."]},{"sp":"Freed","f":"ptr","des":["If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been transferred to this allocator. "]},{"sp":"Untyped","f":"retval","des":["The allocated block of memory is guaranteed to be initialized but may be untyped."]}],"https://doc.rust-lang.org/core/ops/struct.RangeFrom.html#method.get_unchecked-1":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/option/enum.Option.html#method.unwrap_unchecked":[{"sp":"Unreachable","f":"self","des":["Calling this method on `None` is undefined behavior."]}],"https://doc.rust-lang.org/core/intrinsics/fn.volatile_copy_nonoverlapping_memory.html":[{"sp":"Allocated","f":"dst","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"dst","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"DualOwned","f":"dst","des":["If `T` is not `Copy`, using both the values in the region beginning at `self` and the region beginning at `*dst` can violate memory safety. Note that assigning to `*dst` counts as a use because it will attempt to drop the value at `*dst`."]},{"sp":"Layout","f":"dst","des":["`dst` must be properly aligned."]},{"sp":"Leaked","f":"dst","des":[""]},{"sp":"Untyped","f":"dst","des":["The copy is untyped in the sense that data may be uninitialized or otherwise violate the requirements of `T`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size (`count * size_of::<T>()` bytes) starting at the pointer must all be within the bounds of a single allocated object.","The region of memory beginning at `src` with a size of `count * size_of::<T>()` bytes must not overlap with the region of memory beginning at `dst` with the same size."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/core/num/struct.NonZeroUsize.html#method.new_unchecked":[{"sp":"Bounded","f":"n","des":["The value must not be zero."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/ptr/fn.read.html":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"src","des":["`src` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.HandleOrNull.html#method.from_raw_handle":[{"sp":"SystemIO","f":"handle","des":["The passed handle value must either satisfy the safety requirements of `FromRawHandle::from_raw_handle` (below), or be null.","`handle` must be an owned handle; in particular, it must be open.","`handle` must be a handle for a resource that may be freed via `CloseHandle`."]}],"https://doc.rust-lang.org/std/os/windows/io/struct.OwnedSocket.html#method.from_raw_socket":[{"sp":"SystemIO","f":"socket","des":["`socket` must be an owned socket; in particular, it must be open.","`socket` must be a socket that may be freed via `closesocket`."]}],"https://doc.rust-lang.org/core/ptr/fn.read_volatile.html":[{"sp":"DualOwned","f":"retval","des":["If `T` is not `Copy`, using both the returned value and the value at `*src` can violate memory safety. Note that assigning to `*src` counts as a use because it will attempt to drop the value at `*src`.","However, storing non-`Copy` types in volatile memory is almost certainly incorrect."]},{"sp":"Allocated","f":"src","des":["A null pointer is never valid, not even for accesses of size zero.","Even for operations of size zero, the pointer must not be pointing to deallocated memory."]},{"sp":"Dereferencable","f":"src","des":["The memory range of the given size starting at the pointer must all be within the bounds of a single allocated object."]},{"sp":"Initialized","f":"src","des":["`src` must point to a properly initialized value of type `T`."]},{"sp":"Layout","f":"src","des":["`src` must be properly aligned."]}],"https://doc.rust-lang.org/core/iter/trait.Step.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `Self`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.offset-1":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset, in bytes, cannot overflow an `isize`."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/iter/trait.Step.html#method.forward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` + `count` may overflow the range of values supported by `Self`."]}],"https://doc.rust-lang.org/core/any/trait.Any.html#method.downcast_ref_unchecked":[{"sp":"Initialized","f":"self","des":["The contained value must be of type `T`."]}],"https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init_ref":[{"sp":"Initialized","f":"self","des":["It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized state."]}],"https://doc.rust-lang.org/core/primitive.u128.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.u16.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `u16::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i8.html#method.backward_unchecked":[{"sp":"Bounded","f":"start","des":["`start` - `count` may overflow the range of values supported by `i8::MIN`."]}],"https://doc.rust-lang.org/core/primitive.i32.html#method.unchecked_shl":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/primitive.pointer.html#method.add":[{"sp":"Allocated","f":"self","des":[""]},{"sp":"Bounded","f":"self","des":["The computed offset cannot exceed `isize::MAX` bytes."]},{"sp":"Dereferencable","f":"self","des":["Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object."]}],"https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html#method.get_unchecked":[{"sp":"Bounded","f":"self","des":["Calling this method with an out-of-bounds index is undefined behavior even if the resulting reference is not used."]},{"sp":"Allocated","f":"slice","des":["A dangling slice pointer is undefined behavior even if the resulting reference is not used."]},{"sp":"Dereferencable","f":"slice","des":["When `slice` is not dereferenceable is undefined behavior even if the resulting pointer is not used."]}],"https://doc.rust-lang.org/core/primitive.usize.html#method.unchecked_shr":[{"sp":"Bounded","f":"self","des":["This results in undefined behavior if `rhs` is larger than or equal to the number of bits in `self`."]}],"https://doc.rust-lang.org/core/slice/fn.from_raw_parts_mut.html#":[{"sp":"Allocated","f":"data","des":["`data` must be non-null even for zero-length slices."]},{"sp":"Dereferencable","f":"data","des":["The entire memory range (`len * mem::size_of::<T>()` bytes) of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects."]},{"sp":"Initialized","f":"data","des":["`data` must point to `len` consecutive properly initialized values of type `T`."]},{"sp":"Layout","f":"data","des":["`data` must be aligned even for zero-length slices."]},{"sp":"Bounded","f":"len","des":["The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`."]},{"sp":"Aliased","f":"retval","des":["The memory referenced by the returned slice must not be mutated for the duration of lifetime `'a`.","The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context."]}],"https://doc.rust-lang.org/core/mem/fn.transmute.html":[{"sp":"Aliased","f":"retval","des":["It can turn a `*mut T` into an `&mut T`.","It can extend a lifetime, or shorten an invariant lifetime."]},{"sp":"Initialized","f":"retval","des":["Both the argument and the result must be valid at their given type."]},{"sp":"Untyped","f":"retval","des":["It is therefore your responsibility to guarantee that every value passed to transmute is valid at both types `Src` and `Dst`. Failing to uphold this condition may lead to unexpected and unstable compilation results."]},{"sp":"Initialized","f":"src","des":["Both the argument and the result must be valid at their given type.","To transmute the inner type of the contents of a container, you must make sure to not violate any of the container's invariants."]},{"sp":"Layout","f":"src","des":["Both types must have the same size.","Note that source and destination are passed by-value, which means if `Src` or `Dst` contain padding, that padding is not guaranteed to be preserved by transmute.","When transmuting values that point elsewhere (such as pointers, references, boxes…), the caller has to ensure proper alignment of the pointed-to values."]}],"https://doc.rust-lang.org/core/str/fn.from_utf8_unchecked_mut.html":[{"sp":"Initialized","f":"v","des":["The bytes passed in must be valid UTF-8."]}]}}